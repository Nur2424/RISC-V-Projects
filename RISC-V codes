# 2.1 [5] <¬ß2.2> (178 page)

# For the following C statement, write the corresponding RISC-V assembly code. 
# Assume that the C variables f, g, and h, have already been placed in registers x5, x6, and x7 respectively. 
# Use a minimal number of RISC-V assembly instructions.

#	f = g + (h ‚àí 5);

#~ ~ ~ ~ ~ ~ Solution~ ~ ~ ~ ~ ~ ~ ~ ~

# üîß Given:
#	 ‚Ä¢	Variables:
#	   ‚Ä¢	f = x5
#	   ‚Ä¢	g = x6
#	   ‚Ä¢	h = x7

addi x7, x7, -5    # Subtract 5 from the value in register x7 (h = h - 5),
                   # and store the result back into x7.
                   # Now x7 holds (h - 5).

add  x5, x6, x7    # Add the value in x6 (g) to the new value in x7 (h - 5),
                   # and store the result into x5 (f).
                   # Now x5 holds the final result: g + (h - 5).
                   
#-------------------------------------------------------------------------------------------------------------------------------


#2.2 [5] <¬ß2.2> 

#Write a single C statement that corresponds to the two RISC-V
#assembly instructions below.

#	add f, g, h
#	add f, i, f


#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Solution  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

# Step-by-Step Analysis:
# 1. First instruction: 
#   f = g + h  
#   This computes the sum of "g" and "h" and stores it in "f".

# 2. Second instruction:  
#   f = i + f  
#   This takes "i" and adds it to the updated "f" (which is currently "g + h")

# Combined Expression:
# After both instructions execute, the final value in "f" will be. 


#-------------------------------------------------------------------------------------------------------------------------------


# 2.3 [5] <¬ß¬ß2.2, 2.3> 

# For the following C statement, write the corresponding RISC-V assembly code. 
# Assume that the variables f, g, h, i, and j are assigned to registers x5(f), x6(g), x7(h), x28(i), x29(j). 
# Assume that the base address of the arrays A and B are in
# registers x10 and x11, respectively.

# B[8] = A[i‚àíj];


#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Solution ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

# üîß Given:
#	 ‚Ä¢	Variables:
#	   ‚Ä¢	x5 = f
#	   ‚Ä¢	x6 = g
#	   ‚Ä¢	x7 = h
#	   ‚Ä¢	x28 = i
#	   ‚Ä¢	x29 = j
#	 ‚Ä¢	Arrays:
#	   	‚Ä¢	x10 = A (base address of array A[])
#	    ‚Ä¢	x11 = B (base address of array B[])


sub x30, x28, x29 # , x28(i), x29(j)
slli x30, x30, 2
add x30, x30, x10 # x30 + A
lw x5, 0(x30)
addi x30, x11, 32 # x11 = B
sw x5, 0(x30)

#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Explanation  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

    # Load i and j into registers (x28 and x29)
    sub x30, x28, x29        # x30 = i - j
    # Here, we compute the difference i - j, WHICH GIVES THE INDEX OF THE ELEMENT IN "A".

    # Multiply the result of (i - j) by the size of the array element (assuming 4 bytes for integer)
    slli x30, x30, 2         # x30 = (i - j) * 4 (offset in bytes)
    # The result of (i - j) is multiplied by 4 TO ACCOUNT FOR THE SIZE OF THE SIZE OF ONE ELEMENT (assuming 4-byte integers).

    # Add the base address of array A (x10) to get the correct element address
    add x30, x30, x10        # x30 = address of A[i - j]
    # We now add the base address of array A (stored in x10) to the byte offset, 
    # resulting in the address of the element A[i - j].

    # Load the value from array A[i - j] into register x5 (f)
    lw x5, 0(x30)            # f = A[i - j]
    # We load the value from the computed address of A[i - j] into register x5 (which corresponds to 'f').

    # Store the value of f into B[8]
    addi x30, x11, 32        # x30 = address of B[8] (B base address + 8*4 = 32 bytes)
    # Now, we compute the address of B[8] by adding an offset of 32 bytes to the base address of array B (stored in x11).

    sw x5, 0(x30)            # B[8] = f
    # Finally, we store the value from register x5 (which holds f = A[i - j]) into the memory address of B[8].
	# 	‚Ä¢	sw = store a 4-byte value from a register into memory.
	#	‚Ä¢	Format: sw value, offset(address)
	# 	‚Ä¢	In your case: sw x5, 0(x30) ‚Üí store f at address of B[8].

# Summary:
#	‚Ä¢	The assembly code follows the steps in the C statement B[8] = A[i - j].
#	‚Ä¢	It computes the index i - j, converts it to a byte offset, calculates the address of A[i - j], 
#	    loads the value into a register, and stores it in B[8].
#	‚Ä¢	Each instruction has a clear purpose, such as calculating addresses, loading data, or storing data.


#-------------------------------------------------------------------------------------------------------------------------------

#	2.4 [10] <¬ß¬ß2.2, 2.3> 
# For the RISC-V assembly instructions below, what is the corresponding Final corresponding C code would be? 

# Assume that the variables f, g, h, i, and j are assigned to registers x5, x6, x7, x28, and x29, respectively. 
# Assume that the base address of the arrays A and B are in registers x10 and x11, respectively.

slli x30, x5, 3	# x30 = f*8
add x30, x10, x30	# x30 = &A[f]
slli x31, x6, 3	# x31 = g*8
add x31, x11, x31	# x31 = &B[g]
lw x5, 0(x30)	# f = A[f]
addi x12, x30, 8
lw x30, 0(x12)
add x30, x30, x5
lw x30, 0(x31)

# üîß Given:
#	 ‚Ä¢	Variables:
#	   ‚Ä¢	x5 = f
#	   ‚Ä¢	x6 = g
#	   ‚Ä¢	x7 = h
#	   ‚Ä¢	x28 = i
#	   ‚Ä¢	x29 = j
#	 ‚Ä¢	Arrays:
#	   	‚Ä¢	x10 = A (base address of array A[])
#	    ‚Ä¢	x11 = B (base address of array B[])

#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Solution  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

# ‚úÖ Pure C Equivalent:

#	f = A[f];                     // Load the value at A[f] into variable f      
#								  // ‚ÄúLook inside A at position f, take that value, and now that becomes the new f.‚Äù

#	int temp = A[f + 1];          // Load the value at A[f + 1] into a temporary variable	
#								  // Now that f has a new value (from A[f]), this line accesses the next element: A[f + 1].     		

#	int result = temp + f;        // Add A[f + 1] + A[f] and store in result (but not used) 
#	result = B[g];                // Overwrite result with B[g]

#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Explanation  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 


# Assumptions:
# x5  = f       (integer variable f)
# x6  = g       (integer variable g)
# x10 = A       (base address of array A)
# x11 = B       (base address of array B)


# Step 1: Compute byte offset for A[f]
# Each element in A is 8 bytes (e.g., long or double),
# so we multiply f by 8 to get the correct byte address.
slli x30, x5, 3        # x30 = f * 8  (shift left by 3 bits = *8)

# Step 2: Compute the address of A[f]
add x30, x10, x30      # x30 = A + (f * 8) ‚Üí address of A[f]

# Step 3: Compute byte offset for B[g]
# Again, assuming 8-byte elements in array B.
slli x31, x6, 3        # x31 = g * 8

# Step 4: Compute the address of B[g]
add x31, x11, x31      # x31 = B + (g * 8) ‚Üí address of B[g]

# Step 5: Load value at A[f] (4 bytes) into register x5
# This loads only 4 bytes (word) even though elements are 8 bytes.
# Possibly only working with lower 32 bits or this is intentional in the exercise.
lw x5, 0(x30)          # f = A[f] (load word from address in x30 into x5)

# Step 6: Compute address of A[f + 1]
# Since each element is 8 bytes, add 8 to get to A[f+1]
addi x12, x30, 8       # x12 = address of A[f + 1]

# Step 7: Load value at A[f + 1]
lw x30, 0(x12)         # x30 = A[f + 1] (load word from A[f + 1])

# Step 8: Add values A[f] and A[f+1]
# f is now stored in x5, A[f+1] is in x30
add x30, x30, x5       # x30 = A[f + 1] + A[f]

# Step 9: Load value from B[g], overwriting x30
# Final result replaces previous sum with value from B[g]
lw x30, 0(x31)         # x30 = B[g]



#-------------------------------------------------------------------------------------------------------------------------------



#	2.7 [5] <¬ß¬ß2.2, 2.3> 
# Translate the following C code to RISC-V. 

# Assume that the
# variables f, g, h, i, and j are assigned to registers x5, x6, x7, x28, and x29,respectively. 
# Assume that the base address of the arrays A and B are in registers x10 and x11, respectively. 
# Assume that the elements of the arrays A and B are 8-byte words.

# B[8] = A[i] + A[j];


#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Solution  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

# üîß Given:
#	 ‚Ä¢	Variables:
#	   ‚Ä¢	i = x28
#	   ‚Ä¢	j = x29
#	‚Ä¢	Arrays:
#	   ‚Ä¢	A[] base address in x10
#	   ‚Ä¢	B[] base address in x11
#	   ‚Ä¢	Elements are 8 bytes each (use ld and sd)
#	‚Ä¢	Result goes to B[8]

# 1. Calculate address of A[i]
slli x12, x28, 3       # x12 = i * 8 (since elements are 8 bytes)     So, slli x30, x28, 3 means:

add x12, x10, x12      # x12 = address of A[i]

# Load A[i] into register x13
ld x13, 0(x12)         # x13 = A[i]

# 2. Calculate address of A[j]
slli x14, x29, 3       # x14 = j * 8
add x14, x10, x14      # x14 = address of A[j]

# Load A[j]
ld x15, 0(x14)         # x15 = A[j]

# 3. Add A[i] + A[j]
add x16, x13, x15      # x16 = A[i] + A[j]

# 4. Store result to B[8]
li x17, 8              # x17 = 8
slli x17, x17, 3       # x17 = 8 * 8 = 64 (offset for B[8])
add x17, x11, x17      # x17 = address of B[8]
sd x16, 0(x17)         # store result in B[8]



#-------------------------------------------------------------------------------------------------------------------------------


#	2.8 [10] <¬ß¬ß2.2, 2.3> 

# Translate the following RISC-V code to C. 
# Assume that thevariables f, g, h, i, and j are assigned to registers x5, x6, x7, x28, and x29, respectively. 
# Assume that the base address of the arrays A and B are in registers x10 and x11, respectively.

addi x30, x10, 8
addi x31, x10, 0
sw x31, 0(x30)
lw x30, 0(x30)
add x5, x30, x31

# üîß Given:
#	 ‚Ä¢	Variables:
#	   ‚Ä¢	x5 = f
#	   ‚Ä¢	x6 = g
#	   ‚Ä¢	x7 = h
#	   ‚Ä¢	x28 = i
#	   ‚Ä¢	x29 = j
#	 ‚Ä¢	Arrays:
#	   	‚Ä¢	x10 = A (base address of array A[])
#	    ‚Ä¢	x11 = B (base address of array B[])	

#Also assume arrays store 4-byte (32-bit) values (since sw and lw are used)



#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Solution  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 



addi x30, x10, 8       # x30 = A + 8        ‚Üí pointer to A[2] (since 8/4 = 2)
addi x31, x10, 0       # x31 = A            ‚Üí pointer to A[0]
sw x31, 0(x30)         # store A into A[2]  ‚Üí A[2] = A
lw x30, 0(x30)         # x30 = A[2]         ‚Üí load A[2] into x30 (which holds A)
add x5, x30, x31       # f = x30 + x31      ‚Üí f = A + A



# A[2] = (int)A;        // store address of A as an int into A[2]
# f = A[2] + (int)A;    // f = value of A[2] + A (both are treated as int)

# üìå Summary:

#	‚Ä¢	This is a low-level operation treating addresses as integers.
#	‚Ä¢	It‚Äôs more common in systems programming or when implementing pointer tricks.
#	‚Ä¢	The code essentially stores the address of A (pointer) into a memory slot and adds it to itself.



#-------------------------------------------------------------------------------------------------------------------------------



#	2.9 [20] <¬ß¬ß2.2, 2.5> 

# For each RISC-V instruction in Exercise 2.8, 

# Show the valueof the opcode (op), source register (rs1), and destination register (rd) fields. 
# For the I-type instructions, show the value of the immediate field, and for the R-type instructions, 
# show the value of the second source register (rs2). 

# For non U- and UJ-type instructions, show the funct3 field, and for R-type and S-type instructions, also show the funct7 field.

# üèÅ Breakdown of Each Instruction

addi x30, x10, 8

# This is an I-type instruction (immediate-type). The addi instruction performs addition between the immediate value and a register.
#	‚Ä¢	Opcode: addi has an opcode of 0010011.
#	‚Ä¢	rs1: Register x10 (base address of array A).
#	‚Ä¢	rd: Register x30 (result).
#	‚Ä¢	Immediate: 8 (the immediate value added to x10).
#	‚Ä¢	funct3: 000 (for addi).
#	‚Ä¢	funct7: Not relevant for I-type instructions.

# So, the breakdown for addi would be:
#	‚Ä¢	Opcode (op): 0010011
#	‚Ä¢	rs1: x10 (base address of A).
#	‚Ä¢	rs2: N/A (not applicable for I-type instructions).
#	‚Ä¢	rd: x30.
#	‚Ä¢	Immediate: 8.
#	‚Ä¢	funct3: 000.
#	‚Ä¢	funct7: N/A.

‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª

addi x31, x10, 0

# This is also an I-type instruction (immediate-type).
#	‚Ä¢	Opcode: addi has an opcode of 0010011.
#	‚Ä¢	rs1: Register x10 (base address of array A).
#	‚Ä¢	rd: Register x31 (result).
#	‚Ä¢	Immediate: 0 (the immediate value added to x10).
#	‚Ä¢	funct3: 000 (for addi).
#	‚Ä¢	funct7: Not relevant for I-type instructions.

# So, the breakdown for this addi instruction would be:
#	‚Ä¢	Opcode (op): 0010011
#	‚Ä¢	rs1: x10 (base address of A).
#	‚Ä¢	rs2: N/A (not applicable for I-type instructions).
#	‚Ä¢	rd: x31.
#	‚Ä¢	Immediate: 0.
#	‚Ä¢	funct3: 000.
#	‚Ä¢	funct7: N/A.

‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª

sw x31, 0(x30)

# This is an S-type instruction (store-type).
#	‚Ä¢	Opcode: sw has an opcode of 0100011.
#	‚Ä¢	rs1: Register x30 (address where data will be stored).
#	‚Ä¢	rs2: Register x31 (data to be stored).
#	‚Ä¢	Immediate: 0 (the offset from x30 where the data will be stored).
#	‚Ä¢	funct3: 010 (for sw).
#	‚Ä¢	funct7: Not relevant for S-type instructions.

# So, the breakdown for sw would be:
#	‚Ä¢	Opcode (op): 0100011
#	‚Ä¢	rs1: x30.
#	‚Ä¢	rs2: x31.
#	‚Ä¢	rd: N/A (not applicable for store-type instructions).
#	‚Ä¢	Immediate: 0 (store at x30 with no offset).
#	‚Ä¢	funct3: 010.
#	‚Ä¢	funct7: N/A.

‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª

lw x30, 0(x30)

# This is an I-type instruction (load-type).
#	‚Ä¢	Opcode: lw has an opcode of 0000011.
#	‚Ä¢	rs1: Register x30 (base address from where data will be loaded).
#	‚Ä¢	rd: Register x30 (destination where the data will be stored).
#	‚Ä¢	Immediate: 0 (the offset from x30 where the data is loaded from).
#	‚Ä¢	funct3: 010 (for lw).
#	‚Ä¢	funct7: Not relevant for I-type instructions.

#So, the breakdown for lw would be:
#	‚Ä¢	Opcode (op): 0000011
#	‚Ä¢	rs1: x30.
#	‚Ä¢	rs2: N/A (not applicable for I-type instructions).
#	‚Ä¢	rd: x30.
#	‚Ä¢	Immediate: 0 (load from the address in x30 with no offset).
#	‚Ä¢	funct3: 010.
#	‚Ä¢	funct7: N/A.

‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª
add x5, x30, x31

# This is an R-type instruction (register-type).
#	‚Ä¢	Opcode: add has an opcode of 0110011.
#	‚Ä¢	rs1: Register x30 (first operand).
#	‚Ä¢	rs2: Register x31 (second operand).
#	‚Ä¢	rd: Register x5 (result).
#	‚Ä¢	funct3: 000 (for add).
#	‚Ä¢	funct7: 0000000 (for add).

# So, the breakdown for add would be:
#	‚Ä¢	Opcode (op): 0110011
#	‚Ä¢	rs1: x30.
#	‚Ä¢	rs2: x31.
#	‚Ä¢	rd: x5.
#	‚Ä¢	Immediate: N/A (not applicable for R-type instructions).
#	‚Ä¢	funct3: 000.
#	‚Ä¢	funct7: 0000000.

‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª‚∏ª

# +----------------------+----------+------+-------+------+-----------+--------+---------+
#|     Instruction      | Opcode   | rs1  | rs2   | rd   | Immediate | funct3 | funct7  |
# +----------------------+----------+------+-------+------+-----------+--------+---------+
# | addi x30, x10, 8     | 0010011  | x10  | N/A   | x30  | 8         | 000    | N/A     |
# | addi x31, x10, 0     | 0010011  | x10  | N/A   | x31  | 0         | 000    | N/A     |
# | sw x31, 0(x30)       | 0100011  | x30  | x31   | N/A  | 0         | 010    | N/A     |
# | lw x30, 0(x30)       | 0000011  | x30  | N/A   | x30  | 0         | 010    | N/A     |
# | add x5, x30, x31     | 0110011  | x30  | x31   | x5   | N/A       | 000    | 0000000 |
# +----------------------+----------+------+-------+------+-----------+--------+---------+




#-------------------------------------------------------------------------------------------------------------------------------



#	[ 2.10.1 (5) <82.4> 
# What is the value of x30 for the following assembly code?! 

# 	‚Ä¢	x5 = 0x8000000000000000
#	‚Ä¢	x6 = 0xD000000000000000

add x30 x5 x6



#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Solution  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

#	‚ö†Ô∏è Task 1: x30 = x5 + x6

#  					= 0x8000000000000000 + 0xD000000000000000 = 0x15000000000000000


#	‚ö†Ô∏è Task 2: Did overflow occur?

#	Yes, unsigned overflow occurred. Here‚Äôs why:
#		‚Ä¢	The true result of the addition is 0x15000000000000000 ‚Äî a 65-bit value.
#		‚Ä¢	A 64-bit register can‚Äôt hold more than 0xFFFFFFFFFFFFFFFF, so the top bit is lost.

#	For signed interpretation, both x5 and x6 are negative (their MSB is 1), and their sum should be more negative, 
#	but the result (0x5000000000000000) is positive, so signed overflow has occurred too.

#-------------------------------------------------------------------------------------------------------------------------------

# 2.17 

# Assume the following register contents:

#	X5 = 0X00000000AAAAAAAA 
#	X6=0x1234567812345678


#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ Tasks  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


#	‚ö†Ô∏è Task 2.17.1	What is the value of x7 for the following sequence of instructions?

slli x7, x5, 4
or x7, x7, x6

# Given:
# x5 = 0x00000000AAAAAAAA
# x6 = 0x1234567812345678

# Instruction 1: Shift x5 left by 4 bits
slli x7, x5, 4
# x5 << 4 = 0x0000000AAAAAAAA0

# Instruction 2: Bitwise OR with x6
or x7, x7, x6
# 0x0000000AAAAAAAA0 | 0x1234567812345678 = 0x1234567ABAFE5678

# Final result:
# x7 = 0x1234567ABAFE5678


#	‚ö†Ô∏è Task 2.17.2	For the register values shown above, what is the value of x7 for the following sequence of instructions?

slli x7, x6, 4

# Given:
# x6 = 0x1234567812345678

# Instruction: Shift x6 left by 4 bits
slli x7, x6, 4
# x6 << 4 = 0x2345678123456780

# Final result:
# x7 = 0x2345678123456780


#	‚ö†Ô∏è Task 2.17.3	For the register values shown above, what is the value of x7 for the following sequence of instructions?

srli x7, x5, 3
andi x7, x7, OXFEF


# # Given:
# x5 = 0xAAAAAAAA

# Step 1: Convert 0xAAAAAAAA to binary
# 0xA = 1010
# So, 0xAAAAAAAA in binary is:
# 0xAAAAAAAA = 10101010 10101010 10101010 10101010 (32 bits)

# Step 2: Perform a logical right shift by 3 bits 
		srli x7, x5, 3
        
# Shift right by 3: 
# 10101010 10101010 10101010 10101010 >> 3 bits becomes:
# 00010101 01010101 01010101 01010101 (Binary result)

# Step 3: Convert the result back to hexadecimal:
# 00010101 01010101 01010101 01010101 = 0x15555555

# Final result after shifting:
# x7 = 0x15555555

andi x7, x7, OXFEF

## Given:
# x7 = 0x15555555 (result from previous step)
# AND operation with 0xFEF

# Step 1: Convert x7 = 0x15555555 to binary
# 0x15555555 in binary:
# 0x1 = 0001
# 0x5 = 0101
# So, 0x15555555 in binary is:
# 0x15555555 = 00010101 01010101 01010101 01010101 (32 bits)

# Step 2: Convert 0xFEF to binary
# 0xF = 1111
# 0xE = 1110
# 0xF = 1111
# So, 0xFEF in binary is:
# 0xFEF = 1111 1110 1111 (12 bits)

# Step 3: Perform the AND operation (bitwise AND) between x7 and 0xFEF
# Note: We can align the 0xFEF to the lower 12 bits of x7 (fill with leading 0s)

# Align 0xFEF to the lower 12 bits of x7:
# x7 = 00010101 01010101 01010101 01010101
# 0xFEF = 00000000 00000000 00001111 11110111 (12 bits)

# Perform the bitwise AND:
# 00010101 01010101 01010101 01010101  (x7)
# AND
# 00000000 00000000 00001111 11110111  (0xFEF aligned)
# -------------------------------------------
# 00000000 00000000 00000101 01000101  (Result in binary)

# Step 4: Convert the result back to hexadecimal:
# 00000000 00000000 00000101 01000101 = 0x00000545

# Final result after AND operation:
# x7 = 0x00000545


#-------------------------------------------------------------------------------------------------------------------------------

#	2.21 [5] <$2.7> 

# Assume x5 holds the value 0x00000000001010000. What is the value of x6 after the following instructions?

#  		 bge x5, x0, ELSE 
#  		 jal xO, DONE
#  ELSE: ori —Ö6, —Ö0, 2
#  DONE:


# Initial: x5 = 0x00000000001010000 (positive), x0 = 0

# bge x5, x0, ELSE  // Branch to ELSE if x5 ‚â• x0 (true, since 0x00000000001010000 ‚â• 0)
# jal x0, DONE     // Skipped because branch was taken
# ELSE: ori x6, x0, 2  // x6 ‚Üê (x0 OR 2) = (0 OR 2) = 2
# DONE:

# Final value of x6: 2




#---------------------------------------HB-LECTURES------------------------------------------------



# Write RISC-V instructions to perform the following operations.
# HOW many insractions do you need for each multiplications
# 1.	s1 = s0 * 4
slli s1, s0, 2

# 2.	s1 = s0 * 128
slli s1, s0, 7

#3.		s1 = s0 * 9  (9 = 2^3 + 2^0)

slli t0, s0, 3
slli t1, s0, 1
add s1, t1, t0 

#4.		s1 = s0 * 7 (7 = 8 - 1) 

slli s1, s0, 3
add s1, s0, s0

#-------------------------------------------------------------------------------------------------------

# LOADING LARGE CONSTANTS WITH LUI 

# 1) g = 10

addi x8, x0, 10

# We are good at 12-bit immediate most of the time, but sometimes need larger numbers
# How do we load a 32-bit  constant in a register? 

# Example -> 0x12345678 which is in HEX and 32 bit 

# To do that i we another insruction called 

# LUI (Load upper immediate) 



# LUI rd, immd

# LUI allows 20-bit immediate
#	Assembler supports %hiC) to get the higher 20 bits of C
# The 20 bits are placed into bits 12 to bits 31
#	Lower 12 bits are cleared

# Task (1) load 0x12345678 into reister x18

lui x18, 0x12345
addi x18, 0x678 

# if write addi and then lui,lui wil clean them write 0x12345


#-------------------------------------------------------------------------------------------------------

# LUI ACTIVITY AND SOLUTION 

# Write the instruction to load 0x789ABCDE into register x18, so the values should
# appear in x18 register like below:

# 0111 1000 1001 1010 1011 1100 1101 1110

lui x18, 0x789AC 
addi x18, x18, 0xCDE  #sign extended!

#-------------------------------------------------------------------------------------------------------

# IMPORTANT INFO ABOUT MEMORY 

# Memory in just a large, single-dimension array of the bytes

# ¬∞ 1 Byte = 8 bis; 1 Word = 4 bytes = 32 bits 
# ¬∞ Most architectures address indivial bytes in memory 
# ¬∞ Thus, the memory address of the word must be a multiple of 4
# ¬∞ 1 word = 32 bits 
# ¬∞ Visual representaion of the memory throughout the course will be like stack

#-------------------------------------------------------------------------------------------------------

# DEALING WITH MEMORY OPERANDS

# Main memory used for composite data 
	# ¬∞ Array, structure, etc
    # ¬∞ Arithmetic operations occur only on registers 
     
# To apply arithmetic operations on memory contents (data transfer instructions)
	# ¬∞ Load values from memory into registers 
    # ¬∞ Store result from register to memory 
    
# Memory is byte addressed 
	# ¬∞ Each address identifies an 8-bit byte 

# A 32-bit address space supports 5 GiB
	# ¬∞ a 64-bit address space suppors  16 GiB (exbibytes)
    
    
# ‚ö†Ô∏è For Example: you want get 6 from the Array A = [2,3,6,10,15] -> you do A[2] -> And u will get 6
	# Here A is base address
    # 2 is offset 
    
# look for the photo –°–Ω–∏–º–æ–∫ —ç–∫—Ä–∞–Ω–∞ 2025-05-05 –≤ 17.46.11 2


#------------------------------------------------------------------------------

#	Memory Operands Example
 
# Format of Load and Store instuctions 

# ¬∞ LOAD A WORD FROM MEMORY INTO DESTINATION REGISTER 	 
#	¬∞ LOAD: lw R1, Offset(R2)                 [ R -> Destination Register, Offset -> is the constant value,
#		¬∞ REG[R1] = Mem[Reg[R2]+ Offset]		        # R2 -> base address where u wanna first jump into the memory ]
#		 -> Load the contents from memory address R2 + Offset into register R1

# ¬∞ STORE A WORD FROM REGISTER TO MEMORY 
#	¬∞ STORE: sw R3, Offset (R2)
#		¬∞ Mem[Reg[R2] + Offset] = Reg [R3]
#		-> Store the contents of register R3 to memory address R2 + Offset

#			EFFECTIVE ADDRESS: Offset + base address in register ‚ö†Ô∏è 
#			Offset -> is a constant value.Not a register 

# EXAMPLE 

# C CODE:
# g = h + A[7];
#	¬∞ g -> x20, h -> x21, A -> x 22

# COMPILED RISC-V CODE:

lw x9,7(x22)
add x20,x21,x9

# INDEX 7 REGUIRES THE OFFSET OF 28  ‚ö†Ô∏è
#	4 BYTES PER WORD

# THEREFORE -> 

lw x9,28(x22)
add x20, x21, x9 


#------------------------------------------------------------------------------

# MEMORY ACCESS ACTIVITY AND SOLUTION 

# 	C CODE : A[13] = h + A[3]

#	where, 
#		¬∞ h is in x21
#		¬∞ Base address of A in x22
#		¬∞ Save the value of A[3] in reg.x9
#		¬∞ Store addition in reg.x18 

#	WRITE ASSEMBLY CODE 

#~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~~ Solution  ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ 

lw x9, 12(x22)
add x18, x21, x9
sw x18, 52(x22)

#------------------------------------------------------------------------------

# ARRAY INDEXING IN MEMORY 

# WHAT IF THE INDEX IS A LARGE CONSTANT? (A[1050]) 
# WHAT IF THE INDEX IS A VARIABLE? (A[i])

# WE HAVE TO CALUCALE THE ADDRESS WITH HELF OF INSRUCTIONS

# GIVEN AN INDEX,WE COMPUTE THE ADDRESS OF THE ELEMENT BY: 
#	¬∞ Multiplying index by ELEMENT SIZE to get OFFSET 
#	¬∞ Adding OFFSET to the base address 


# CALCULATE THE ADDRESS OF A[1024]

addi t0, x0, 1024
slli t0, t0, 2			# 1024 * 4 -> addr of A[1024]
add t0, t0, s1			# Assume Base address of A in s1

# use t0 in load/store insructions 


# CALCULATE ADDRESS OF A[i], where i is in register s2 

slli t0, s2, 2		# i * 4
add t0, t0, s1		# Effective Addr of A[i] in t0 

# use t0 in load/store insructions

lw s2, t0(s1) # is wrong! ‚ùå
lw s2, 0(t0) # is correct! ‚úÖ


#------------------------------------------------------------------------------

# COPYING ONE ARRAY TO ANITHER ARRAY,ACTIVITY

# C CODE FOR COPYING ARRAY IS GIVEN BELOW: 

# for (i = 0; i < 100; i++)
# 	B[i] = A [i];

#  RISC-V code 



# Register Usage:
# --------------------------------
# | Variable      | Register     |
# --------------------------------
# | i             | s1          |
# | A's address   | s2          |
# | B's address   | s3          |
# | Initial value | s4 (100)    |
# -------------------------------- 


addi s4, x0, 100
addi s1, x0, 0
# beq x0, x0, test  # we know initially s1 < s4

loop:
	  slli t0, s1, 2		# t0 = i * 4
	  add t2, t0, s2		# compute address of A[i]
	  lw t1, 0(t2)		
	  add t3, t0, s3		# compute address of B[i]
	  sw t1, 0(t3)
	  addi s1, s2, 1 		# incrementing i
test: bne s1, s4, loop      # test loop condition 



#------------------------------------------------------------------------------

# BYTE ORDER, BIG AND LITTILE EDNIAN FORMAT 

# ENDIANNES 

# X1 IS 0X01020304
# sw x1, 0x100(X0)

# BIG-ENDIAN: THE HIGHIEST BYTE GOES TO THE SLOWEST MEMORY ADDRESS 

# Memory Layout:
# --------------------------------
# | Address        | Value      |
# --------------------------------
# | 0x0000 0103    | 0x04      |
# | 0x0000 0102    | 0x03      |
# | 0x0000 0101    | 0x02      |
# | 0x0000 0100    | 0x01      |
# --------------------------------

# LITTLE-ENDIAN: THE LOWEST BYTE GOES TO THE LOWEST MEMORY ADDRESS  (RISC-V USES THIS TYPE)

# Memory Layout (Little-Endian Example):
# --------------------------------
# | Address        | Value      |
# --------------------------------
# | 0x0000 0103    | 0x01      |
# | 0x0000 0102    | 0x02      |
# | 0x0000 0101    | 0x03      |
# | 0x0000 0100    | 0x04      |
# --------------------------------

# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

# 354F

# --------------------------------
# | Address   | Value   | Label  |
# --------------------------------
# | 0x1000    | 0x3S    | B: E   |
# | 0x1001    | 0x4F    | L: E   |
# --------------------------------

# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

# WHAT ARE THE BITS IN T0 AFTER EXECUTING THE FOLLOWING RISC-V INSTRUCTION? 

lw t0, 0x200(x0)

# --------------------------------
# | Address        | Value      |
# --------------------------------
# | 0x0000 0203    | 0x32      |z
# | 0x0000 0202    | 0x65      |
# | 0x0000 0201    | 0x81      |
# | 0x0000 0200    | 0xAC      |
# --------------------------------

# ANSWER IS: 0x326581AC


#------------------------------------------------------------------------------

# TRANSFERING DATA OF OTHER SIZE

# ¬∞ RISC-V SUPPPORTS DATA OF OTHER SIZES
#	¬∞ EACH TYPE CAN BE SIGNED OR UNSIGNED 

# RISC-V Data Types and Memory Operations
# ====================================================
# Data Type Reference:
# ----------------------------------------------------
# | Size (bits) | Name       | C Type        |
# ----------------------------------------------------
# | 8           | byte       | char          |
# | 16          | half word  | short int     |
# | 32          | word       | int, long int |
# ----------------------------------------------------
#
# Load/Store Instructions:
# ----------------------------------------------------
# Load Signed (sign-extended):
#   lb  rd, offset(rs1)    # Load byte (8b ‚Üí 32b sign-ext)
#   lh  rd, offset(rs1)    # Load halfword (16b ‚Üí 32b sign-ext)
#
# Load Unsigned (zero-extended):
#   lbu rd, offset(rs1)    # Load byte unsigned (8b ‚Üí 32b 0-ext)
#   lhu rd, offset(rs1)    # Load halfword unsigned (16b ‚Üí 32b 0-ext)
#
# Store (lowest bits only):
#   sb  rs2, offset(rs1)   # Store byte (32b ‚Üí 8b truncate)
#   sh  rs2, offset(rs1)   # Store halfword (32b ‚Üí 16b truncate)
#
# Notes:
# - All offsets are 12-bit signed immediates (-2048 to 2047)
# - 'long int' is 32b in RV32, 64b in RV64
# ====================================================  


# DATA TRANSFER 

# | Instruction Type        | Assembly Format   |       Pseudocode       |       Description                          |
# | Load word               | 1w x5, 40(x6)     | x5 = Memory[x6 + 40]   | Word from memory to register          |
# | Store word              | sw x3, 40(x6)     | Memory[x6 + 40] = x5   | Word from register to memory          |
# | Load halfword           | 1h x5, 40(x6)     | x5 = Memory[x6 + 40]   | Halfword from memory to register      |
# | Load halfword, unsigned | 1hu x5, 40(x6)    | x5 = Memory[x6 + 40]   | Unsigned halfword to register         |
# | Store halfword          | sh x5, 40(x6)     | Memory[x6 + 40] = x5   | Halfword to memory                    |
# | Load byte               | 1b x5, 40(x6)     | x5 = Memory[x6 + 40]   | Byte to register (sign-extended)      |
# | Load byte, unsigned     | 1bu x5, 40(x6)    | x5 = Memory[x6 + 40]   | Byte to register (zero-extended)      |
# | Store byte              |  sb x5, 40(x6)    | Memory[x6 + 40] = x5   | Byte to memory                        |
# | Load reserved           | lr.d x5, (x6)     | x5 = Memory[x6]        | Atomic load (for RVA extension)       |
# | Store conditional       | sc.d x7, x5, (x6) | Memory[x6] = x5; x7=0/1| Atomic store (sets success/fail flag) |
# | Load upper immediate    | lui x5, 0x12345   | x5 = 0x12345000        | Load 20-bit constant << 12 bits       |
 


# DATA TRANSFER INSRUCTIONS 

# ¬∞ LB or LBU insruction loads a byte from memory to a register 
#		¬∞ LB: the byte is sign extended to a word 
#		¬∞ LBU: the byte is zero extended to a word   

# ¬∞ SB insruction stores a byte in a register to a memory 
#		¬∞ Only the lowest 8 bit of the register are stored

# REGISTEER     MEMORY
#        <------- LB LBU
#     SB  --------> 

# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 


# WHAT IS THE VALUE IN T0 AFTER EXECUTING THE FOLLOWING RISC-V INSRUCTIONS ? 

lb t0, 0x201(x0)
 
# --------------------------------
# | Memory Address | Value      |
# --------------------------------
# | 0x0000 0203    | 0x32       |
# | 0x0000 0202    | 0x65       |
# | 0x0000 0201    | 0x81       |
# | 0x0000 0200    | 0xAC       |
# --------------------------------

# Answer : 0xFFFF FF81



# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

# WHAT IS THE VALUE IN T0 AFTER EXECUTING THE FOLLOWING RISC-V INSRUCTIONS ? 

lh t0, 0x200(x0)


# --------------------------------
# | Memory Address | Value      |
# --------------------------------
# | 0x0000 0203    | 0x32       |
# | 0x0000 0202    | 0x65       |
# | 0x0000 0201    | 0x81       |
# | 0x0000 0200    | 0xAC       |
# --------------------------------

# Answer : FFFF 81AC


#----------------------------------------------------------------------------------------------------


# DEALING WITH BYTE ARRAYS


# If S is a byte array, how do we calculate the address of S[i]?

# Assume the base address of S is in S1 and i is in S2
# We would like to save the address of S[i] in t0


# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

# Copy string S to D


# C code

char c;
int i = 0;

do {
    c = s[i];
    d[i] = c;
    i += 1;
} while (c);

# This is a typical string copy loop ‚Äî it copies characters from one memory location to another 
#     until it hits the null terminator ('\0'), which marks the end of the string.







# RISC V code


Register Mapping (what we assume):
	‚Ä¢	a1 ‚Üí holds the address of the source string s ‚úÖ
	‚Ä¢	a0 ‚Üí holds the address of the destination string d ‚úÖ
	‚Ä¢	t0 ‚Üí used as a temporary register to hold c (i.e., the character we just copied) ‚úÖ


    li t1, 0              # We need a variable for 'i' (the index). RISC-V doesn't have named variables,
                          # so we use register t1 for 'i' and set it to 0 (i = 0).

loop:
    add t2, a1, t1        # We compute the address of s[i] by adding i (t1) to the base address of s (a1).
                          # Remember, in RISC-V, we can't use array-style access like s[i],
                          # so we compute the actual memory address manually.

    lbu t3, 0(t2)         # Load the byte at address s[i] into t3.
                          # We use lbu (load byte unsigned) to load a single character (1 byte).
                          # This corresponds to: c = s[i];

    add t2, a0, t1        # Now compute the address of d[i] by adding i (t1) to the base address of d (a0).

    sb t3, 0(t2)          # Store the byte from t3 (which is c) into d[i].
                          # This is equivalent to: d[i] = c;

    mv t0, t3             # Copy the value of c into t0.
                          # We'll use t0 to check whether the loop should continue.
                          # (Technically, this isn't strictly necessary since we could use t3 directly,
                          # but it's done here for clarity and matches your C code: `c = s[i];`.)

    addi t1, t1, 1        # i = i + 1;
                          # Increment the index to move to the next character in the next iteration.

    bnez t0, loop         # If c != 0, go back to the start of the loop.
                          # This means: if we haven‚Äôt reached the end of the string (null terminator),
                          # keep copying the next character.




#----------------------------------------------------------------------------------------------------

# FUNCTIONS IN RISC V 

¬∞ AS WE KNOW,REGISTERS ARE FASTEST PLACE TO HOLD DATA IN A COMPUTER

¬∞ Registers are reserved for funstion calling 
   ¬∞ x10 - x17: for parameter/return values
   ¬∞ x1: for holding return address


############################################################
# RISC-V Register Usage for Function Arguments / Results   #
# -------------------------------------------------------- #
# x10 (a0) : 1st argument / return value                   #
# x11 (a1) : 2nd argument                                  #
# x12 (a2) : 3rd argument                                  #
# x13 (a3) : 4th argument                                  #
# x14 (a4) : 5th argument                                  #
# x15 (a5) : 6th argument                                  #
# x16 (a6) : 7th argument                                  #
# x17 (a7) : 8th argument                                  #
#                                                          #
# a0‚Äìa7 are used to pass parameters into functions         #
# and to return values from them  			   #

# Register to hold the address of the next insruction RETURN ADDRESS X1 # 

############################################################


# Jump-and-Link Instruction 

jal rd, function_name   <-------- Function name is just a label,indicating a memory address

# ¬∞ jump and link (JAL) for procedure call
#	¬∞ GO to the label (where the procedure/function starts)
#	¬∞ And save the address of the following instruction (PC+4) in rd 

# ¬∞ rd can be any register 
#	¬∞ Save return address in x1(or ra) for function calls

# ¬∞ J is a pseudoinstruction for jupm
#	¬∞ It is a JAL instruction that writes to x0
#	¬∞ There is no separate jump instruction in RISC V

# ¬∞ Now the return address is in a register, e.g., ra or x1. How actually go there? 
#	¬∞ JAL does not take a sourse register

# ¬∞ We need another insruction that can jump to the address in a register "JALR" (to comeback from the function execution )


# ¬∞ To return from the function 
 
jalr rd, offset(rs1)
jalr x0, 0(x1)

# ¬∞ Procedure call or return: jump and link to address in a register 
#	¬∞ Go to the address computed as Reg[rs1] + offset 
#	¬∞ Saves the address of the following insruction (PC + 4) in rd 

# ¬∞ The return address is saved in rd
#	¬∞ If the ruturn address is not needed, use x0 ad rd



#----------------------------------------------------------------------------------------------------

# QUICK FUNCTIONS OVERVIEW WITH EXAMPLE

# EXAMPLE

main: jal, ra,foo.  # main is the lebal,it corresponds address of the insruction 


############################################################
# RISC-V Function Call Example                             #
# -------------------------------------------------------- #
# main:                                                    #
#   jal ra, foo        # 1. Jump to foo, save return addr in ra (x1)
#   add s0, s0, a0     # 4. Continue after foo returns: use result
#                                                          #
# foo:                                                     #
#   add t1, a0, x0     # 2. Use function argument a0       #
#   ...                #    Do some work (e.g., xor, etc.) #
#   xor t0, t2, t3                                          #
#   ...                                                    #
#   jalr x0, 0(x1)     # 3. Return to caller using ra      #
#                      #    jalr sets PC = x1 (return addr)#
############################################################

# So, in short:
# main calls foo, gets a result in a0, and adds that result to s0. 
# This is a classic function call pattern in RISC-V:



#----------------------------------------------------------------------------------------------------

TRANSLATING C FUNCTION INTO RISCV V CODE 

############################################################
# C CODE                                 #
# int abs(int n) {                                         #
#     int rv = n;                                          #
#     if (n < 0) rv = -n;                                  #
#     return rv;                                           #
# }                                                        #
############################################################

HOW DOES THE FUNCTION GET THE ARGUMENT? 
HOW DOES THE FUNCTION PASS THE REURN VALUE TO THE CALLER?

# ¬∞ First eight parameters/arguments are passed to the function in x10, x11, X12, x13, X14, X15, x16, x17 (RISC-V) 
#							or
#                               	ao, al, a2, –∞3, a4, –∞5, –∞–±, a7 (RARS)
# ¬∞ÔªøÔªøTwo values can be returned in x10 (a0) and x11 (a1)
#      ¬∞ÔªøÔªøIf only one value is returned, it is in x10 (a0)


# Caller and callee communicate through these registers only
	# Not through registers like s1, s2 (saved registers x9, x18, ...)

For example, a function cannot assume s1 has an address it needs


############################################################
# RISC-V Implementation of:                                #
# int abs(int n) {                                         #
#     int rv = n;                                          #
#     if (n < 0) rv = -n;                                  #
#     return rv;                                           #
# }                                                        #
############################################################

abs:                          # Function label (entry point)
    bge   a0, x0, exit        # If a0 >= 0 (n >= 0), skip negation
    sub   a0, x0, a0          # Else, a0 = 0 - a0 = -n
exit:
    jalr  x0, 0(ra)           # Return to caller using return address in ra

# NOTE:
# - Input:  a0 holds `n` (argument)
# - Output: a0 holds return value (same register)
# - Only 3 instructions total!

############################################################
# CALLER EXAMPLE: (calling abs(-2))                        #
# This code is outside the function, sets up input & calls #
############################################################
    addi  a0, x0, -2          # Set a0 = -2 (pass -2 as argument)
    jal   ra, abs             # Call abs function (return address in ra)

# After return:
# - a0 will hold the result of abs(-2), which is 2
# - You can now use a0 in main or store it
############################################################



#----------------------------------------------------------------------------------------------------


# HOW LARGE NUMBER OF VARIABLES IN A FUNCTION ARE HANDLED

#	WHAT IF A PROCEDURE NEEDS MORE VARIABLES? 
#	HOW DO WE PROCESS MORE ARGUMENTS OR VARIABLES? 

# We can spill the register contents in memory 
# Store original conttent to memory use this register then load back content into register 


#----------------------------------------------------------------------------------------------------

# USING STACK TO MENAGE SPILLED CONTENTS 

# WE CAN SPILL THE REGISTER CONTENTS IN MEMORY
# DATA STUCTURE USED TO ORGANIZE THE SPILLED DATA IS "STACKS"

# ¬∞ Stack needs pointer to point to the top of stack
# ¬∞ In RISC V, stack pointer is register x2, aslo known as sp

# ¬∞ Operations:
#	¬∞ PUSH
#	¬∞ POP

# Grows from higher address to lower address

#   MEMORY 
# |-------|
# |	  | 
# |	  |
# ||||||||| ----> sp	  |
# |   |   |
# |   |	  | 
# |   v   | 
# |-------|


#   MEMORY  PUSHING ELEMENTS 
#   push x20


# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

# Push x20 onto the stack

addi sp, sp, -4    # Move the stack pointer down by 4 bytes (32 bits) to make space
sw x20, 0(sp)      # Store the value of x20 into the memory at the new top of the stack


# |-------|
# |	  | 
# |	  |
# |	  |
# |	  |
# |||x20|||
# ||||||||| ----> sp	  
# |   |   |
# |   |	  | 
# |   v   | 
# |-------|

# Why 4 bytes?

# Each word in RISC-V is 4 bytes (since it‚Äôs a 32-bit architecture). 
# So to ‚Äúpush‚Äù one word onto the stack, you need to make space for 4 bytes. 
# Subtracting 4 from sp moves it down the stack by 4 memory addresses (i.e., one word of space).

# So it‚Äôs not shifting the contents by 4 bytes ‚Äî it‚Äôs moving the stack pointer down by 4 bytes 
# to reserve space for storing one word.


# sw x20, 0(sp)          # Store the word in x20 at the address (sp + 0)
                         # The '0' is an offset ‚Äî here it's 0 because sp already points to the desired location
                         # You could use another number (e.g., 4(sp), 8(sp)) to access deeper stack positions



# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

# POP x20

lw x20, 0(sp)
addi sp, sp, 4


#----------------------------------------------------------------------------------------------------


# PUSH AND POP OPERATIONS TO MOVE CONTENTS TO ---> STACK OR FORM <------ STACK 


# WRITE RISC V INSTRUCTIONS FOR THE FOLLOWING OPERATIONS 

# ¬∞ push ra(x1) onto the stack 

addi sp, sp, -4  # ---another-version-----> addi x2, x3, -4
sw ra, 0(sp)     # ---another-version-----> sw x1, 0(x2)

# ¬∞ pop ra(x1) from the stack 

lw ra, 0(sp)    # ---another-version-----> lw x1, 0(x2)
addi sp, sp, 4  # ---another-version-----> addi x2, x2, 4



# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 


# WRITE RISC V INSTRUCTIONS TO PUSH S1, S2, S3 ONTO THE STACK

# Instead of 3 ADDIs, we can adjust sp once for three words 

# reserce space for 3 words

addi sp, sp, -12
sw s1, 8(sp)
sw s1, 4(sp)
sw s1, 0(sp)

 # Address     | Value
 # ---------------------------------------------
 # 0x7FFF901C  | 
 # ---------------------------------------------
 # 0x7FFF9018  | 				  <------ sp before pushing space
 # ---------------------------------------------
 # 0x7FFF9014  | 
 # ---------------------------------------------
 # 0x7FFF9010  | s1    (variable s1 stored here)
 # ---------------------------------------------
 # 0x7FFF900C  | s2    (variable s2 stored here)
 # ---------------------------------------------
 # 0x7FFF9008  | s3    (variable s3 stored here) <------ sp after pushing space
 # ---------------------------------------------
 # 0x7FFF9004  | 
 # ----------------------------------------------
 # 0x7FFF9000  |


# ¬∞ POP  s1, s2, s3

lw s1, 8(sp)
lw s2, 4(sp)
lw s3, 0(sp)

addi sp, sp, 12 # restore sp after loads

Another way doing this
# ¬∞ POP  s1, s2, s3

lw s1, 8(sp)
addi sp, sp, 4
lw s2, 4(sp)
addi sp, sp, 4
lw s3, 0(sp)
addi sp, sp, 4



#----------------------------------------------------------------------------------------------------

# SPLLING DATA INTO MEMORY - ACTIVITY

# C CODE 

int leaf_example (int g, int h, int i, int j )
{
	int f;
	f = Ôºà g + h Ôºâ-Ôºà i + j );
	return f;
}

WHAT IS THE RISC V COMPLIED CODE?

g  -----‚Üí x10
h  -----‚Üí x11
i  -----‚Üí x12
j  -----‚Üí x13

f  -----‚Üí x20

Registers to hold intermediate results 

x5: g + h
x6: i + j

leaf example:   #spill x5, x6, x20
		   addi sp, sp, -12 
		   sw X5, 8(sp)
		   sw X6, 4(sp)
		   sw x20, 0(sp)
		#arithmetic
		  add x5, x10, x11
		  add x6, x12, x13
		  sub x20, x5, x6 
	        #return f (x20)
		  addi x10, x20, 0
 	       #restored spilled data
		  lw x20, 0(sp)
                  lw x6, 4(sp)
		  lw x5, 8(sp)
                  addi sp, sp, 12 
	       #return control 
		  jalr xo, 0(x1) 


# ‚Ä¢ Old values of registers x5, x6, and x20 were spilled in memory and restored
# ‚Ä¢ Sometimes values are never used and thus they must be categorized as "temporary" values and should not be restored
# ‚Ä¢ Temporary Registers: x5 - x7, x28 - x31
# ‚Ä¢ Saved Registers: x8 - x9, x18 - x27

# ‚Üí Temporary register contents thus not need to be spilled into memory
# ‚Üí In previous example, two sw and two lw instructions could be avoided (for x5 and x6)


#----------------------------------------------------------------------------------------------------

# ¬∞ Procedures that do not call other procedures are called LEAF PROCEDURES 

# ¬∞ RECURSIVE PROCUDURES INVOKE CLONES OF THEMSELVES 


Nested Runctions/Procedures 

# C CODE 

int fact (int n)
     {
       if (n < 1) return (1);
       else return (n * fact(n - 1));

fact(3)

int fact (int n)
     {
       if (n < 1) return (1);				<----- n = 3
       else return (n * fact(n - 1)); 
}


int fact (int fact (int n)
     {
       if (n < 1) return (1);				<----- n = 2
       else return (n * fact(n - 1)); 
}


int n)
     {
       if (n < 1) return (1);				<----- n = 1
       else return (n * fact(n - 1)); 
}


int fact (int n)
     {
       if (n < 1) return (1);				<----- n = 0
       else return (n * fact(n - 1)); 
}


CONSIDER THAT:

return address is stored in x1
the first argument is stored in x10
the returned value is stored in x10 (overwrite the passed argument value)

# RISC V IMPLEMENTATION OF THIS FUNCTION 

fact:
	# if (n < 1) return 1
	addi t0, zero, 1
	bge a0, t0, else	# go to else branch if n >= 1

	# if branch 
	addi a0, zero, 1	# set return value 1
	beq x0, x0, exit	# go to exit

else: # else n * fact(n - 1)
	addi a0, a0, -1		# cumpute fact(n - 1)
	jal ra, fact
	mul a0, a0, a0	# n * (n - 1)!
exit:
	jarl x0, ra, 0



#----------------------------------------------------------------------------------------------------



# RISV V INSTRUCTION FORMAT 

# ¬∞ Everything in computer is represented with binary and so the Instructions as well
#	¬∞ Called machine code
# ¬∞ How many bit should we use to encode instructions ? 
# ¬∞ Are we using the same number of bits to encode all instructions ?
#	¬∞ Do all instructuons have the same length ?


addi rd, rs1, rs2
addi rd, rs1, immd
lw rd, offset(rs1)	#same format for jalr
sw rs2, offset(rs1)
beq rs1, rs2, LABEL
jal rd, Function_name



Design Principle 4

‚ÄúGood design demands good compromises‚Äù in the context of RISC-V, they mean that the architecture was 
carefully designed to balance simplicity, flexibility, and performance‚Äînot to be the absolute best in 
any single dimension, but to make smart trade-offs that support a wide range of uses.

Keep formats as similar as possible

             ----------------------------
INSTRUCTION |		32 bits 	|
	     ----------------------------

# ¬∞ RISC V instructions words
       ¬∞ Encode as 32-bits instructions words
       ¬∞ Small number of formats encoding operation code (opcode), Register numbers 

 ¬∞ Regularity!


# ¬∞  RISC V has six instruction formats
#	¬∞ R, I, S, SB, U, UJ

#----------------------------------------------------------------------------------------------------

# RISC V Instruction Format - R Type

|--------|--------|---------|--------|--------|--------|
| funct7 |  rs2   |   rs1   | funct3 |   rd   | opcode | 
|--------|--------|---------|--------|--------|--------|
| 7 bits | 5 bits | 5 bits  | 3 bits | 5 bits | 7 bits |
|--------|--------|---------|--------|--------|--------|


# Fields:
#   opcode : 7-bit operation code
#   rd     : destination register number (5 bits)
#   rs1    : first source register number (5 bits)
#   rs2    : second source register number (5 bits)
#   funct3 : 3-bit function code (additional specification)
#   funct7 : 7-bit function code (further specification)


# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 


|--------|--------|---------|--------|--------|--------|
| funct7 |  rs2   |   rs1   | funct3 |   rd   | opcode | 
|--------|--------|---------|--------|--------|--------|
| 7 bits | 5 bits | 5 bits  | 3 bits | 5 bits | 7 bits |
|--------|--------|---------|--------|--------|--------|

a = b + c
|
|    <------ Assembler 
|			    
v			    
add x9, x20, x21

|--------|--------|---------|--------|--------|--------|
|   0    |   21   |    20   |    0   |    9   |    51  | 	# 51 = 0110011
|--------|--------|---------|--------|--------|--------|

  			    |
			    |
			    |
			    v

|--------|--------|---------|--------|--------|--------|
|0000000 | 10101  | 10100   |  000   |  01001 |0110011 | 
|--------|--------|---------|--------|--------|--------|
 
0000	0001	0101	1010	0000	0100	1011	0011    <------ machine code 


			    |
			    |
			    v

			015A04b3_16 			<-------- hex format 


# ANY INSTRUCTIONS WITH 3 COMPONENTS CAN BE REPRESENTED WITH R-FORMAT 


# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 


What is the RISC V instruction does this represented? 

The numbers are in decmimal 

|--------|--------|---------|--------|--------|--------|
| funct7 |  rs2   |   rs1   | funct3 |   rd   | opcode | 
|--------|--------|---------|--------|--------|--------|
|   32   |    9   |   10    |    0   |   11   |   51   | 
|--------|--------|---------|--------|--------|--------|


Solution: sub x11, x10, x9




| Instruction   | opcode   | funct3 | funct7
| ------------- | -------- | ------ | -------
| add           | 0110011  | 000    | 0000000
| sub           | 0110011  | 000    | 0100000
| sll           | 0110011  | 001    | 0000000
| slt           | 0110011  | 010    | 0000000
| sltu          | 0110011  | 011    | 0000000
| xor           | 0110011  | 100    | 0000000
| srl           | 0110011  | 101    | 0000000
| sra           | 0110011  | 101    | 0100000
| or            | 0110011  | 110    | 0000000
| and           | 0110011  | 111    | 0000000


#----------------------------------------------------------------------------------------------------



# RISC V Instruction Format - I Type

|---------|-----|--------|----|--------|
|immediate| rs1 | funct3 | rd | opcode |
|---------|-----|--------|----|--------|
| 12 bits |  5  |   3    |  5 | 7 bits |
|---------|-----|--------|----|--------|


¬∞ Immediate arithmetic and load instructions
	¬∞ rs1. source or base address register number 
	¬∞ immediate : constant, or offset added to base address
		¬∞ 2s-comlement, sign extended

¬∞ Since only 12 bits are kept in machine code, 
    the immediate must be in [-2^11, +2^11-11 or [-2048, 2047]


# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

addi x1, x2, 32 

|---------------|-------|-----|-------|--------|
|0000 0010 0000 | 00010 | 000 | 00001 | 0010011|
|---------------|-------|-----|-------|--------|

When executing the instruction, processor builds a 32-bit immediate imm by extending the sign bit

    |---imm[31:12]--------|---imm[11:0]----|	
imm |0000 0000 0000 00000 | 0000 00010 0000|
    |---------------------|----------------|




| ------------- | -------- | -------|
| Instruction   | opcode   | funct3 
| ------------- | -------- | -------|
| addi          | 0010011  | 000    
| slli          | 0010011  | 001
| slti          | 0010011  | 010
| sltiu         | 0010011  | 011
| xori          | 0010011  | 100
| srli          | 0010011  | 101
| srai          | 0010011  | 101
| ori           | 0010011  | 110
| andi          | 0010011  | 111
| ------------- | -------- | -------|

# In sili, srli, and srai, only lower 5 bits of the immediate are used for shift amount. 
#   5 bits are enough for 32-bit registers!



#----------------------------------------------------------------------------------------------------

# RISC V Instruction Format - I Type (srli and srai)

| ------------- | -------- | -------|
| Instruction   | opcode   | funct3 
| ------------- | -------- | -------|
| addi          | 0010011  | 000    
| slli          | 0010011  | 001
| slti          | 0010011  | 010
| sltiu         | 0010011  | 011
| xori          | 0010011  | 100
| srli          | 0010011  | 101	<--------- same 
| srai          | 0010011  | 101	<--------- same 
| ori           | 0010011  | 110
| andi          | 0010011  | 111
| ------------- | -------- | -------|



# - - - - - - - - - - - - EXAMPLE - - - - - - - - - - - - 

|-------|---------|-----|--------|----|--------|
| funct7|immediate| rs1 | funct3 | rd | opcode |
|-------|---------|-----|--------|----|--------|
| 7bits | 12 bits |  5  |   3    |  5 | 7 bits |
|-------|---------|-----|--------|----|--------|

srli x1, x2, 16

# More than 31 times shift is not needed(it gets 0), 
#	therefore the maximum immediate value, i.e. 31, can be represented in 5 bits.

# Remaining 7 bits can be repurposed as an additional funct7 field


srli x1, x2, 16
|---------------------------------------------------|
|0*0*00 000 | 1 0000 | 0010 | 101 | 00001 | 0010011 | 
|---------------------------------------------------|

srai x1, x2, 16
|---------------------------------------------------|
|0*1*00 000 | 1 0000 | 0010 | 101 | 00001 | 0010011 | 
|---------------------------------------------------|

				---------
srli	0010011		101	| 00000 |   <------ funct7
srli	0010011		101	| 00000 |   <------ funct7
				---------

#----------------------------------------------------------------------------------------------------



# RISC V Instruction Format - I Type (load variants)

lw x1, 32(x2)

|-----------------------------------------------|
|0000 0010 0000 | 00010 | 010 | 00001 | 000 011 |
|-----------------------------------------------|

/**************************************************************
 * RISC-V Load Instruction Encoding Table                      *
 *                                                            *
 * This table shows how different load operations are encoded *
 * in the RISC-V instruction set.                             *
 *                                                            *
 * +------+-----------+--------+------------------------------+
 * | type | opcode    | funct3 | Description                  |
 * +------+-----------+--------+------------------------------+
 * | lb   | 0000011   | 000    | load byte (signed)           |
 * | lh   | 0000011   | 001    | load halfword (signed)       |
 * | lw   | 0000011   | 010    | load word (signed)           |
 * | ld   | 0000011   | 011    | load doubleword (RV64 only)  |
 * | lbu  | 0000011   | 100    | load byte unsigned           |
 * | lhu  | 0000011   | 101    | load halfword unsigned       |
 * | lwu  | 0000011   | 110    | load word unsigned (RV64)    |
 * +------+-----------+--------+------------------------------+
 *                                                            *
 * Notes:                                                     *
 * - All load instructions share the same opcode (0000011)    *
 * - funct3 field differentiates between operation types      *
 * - lw entry appears to have a typo (extra ^ character)      *
 **************************************************************/


#----------------------------------------------------------------------------------------------------

 # RISC V Instruction Format - S Type
 # Store instruvtions have their own format
 # sw - sb - sh - 

# S-FORMAT 

|---------|---------|--------|--------|----------|--------|
|imm[11:5]|   rs2   |   rs1  | funct3 | imm[4:0] | opcode |
|---------|---------|--------|--------|----------|--------|
| 7 bits  | 5 bits  | 5 bits | 3 bits | 5 bits   | 7 bits |
|---------|---------|--------|--------|----------|--------|


# ¬∞ DIFFERENT IMMEDIATE RORMAT FOR STORE INSTRUCTIONS 
#	¬∞ rs1: base Register, Base address of store 
#	¬∞ rs2: source register, data to be stored in memory 
#	¬∞ immediate: offset added to base address 
#		¬∞ Split so that rs1 and r2 fields always remain in the same place 



# sw x1, 32(x2)   # The 12 bits of the immediate are saved in two fields 

        sw x1, 32(x2)

|   imm[11:5]   |  x1  	|  x2	|     | imm[4:0]| sw oppcd|
|---------------|-------|-------|-----|---------|---------|
|    0000 001   | 00001 | 00010 | 010 |  00000  | 0100011 |
|-----------------------------------------------|---------|



# EXAMPLE

|---------|---------|--------|--------|----------|--------|
|imm[11:5]|   rs2   |   rs1  | funct3 | imm[4:0] | opcode |
|---------|---------|--------|--------|----------|--------|
| 0000001 |  00010  | 00010  |   010  |  00100   |0100011 |
|---------|---------|--------|--------|----------|--------|
|   |		|	|	 |	   |	     |
|   |		V	v	 v	   |	     |
    |         source   base    store 	   |	     |
    |	       x14	x2	word	   |	     v
    v					 |       S TYPE
|-----------|----------|	<-------|	 opcode 
| imm[11:5] | imm[4:0] |
|-----------|----------|
|  0000001  | 00100    |
|-----------|----------|
      |          |
      v          v

	"offset"


#----------------------------------------Activity-------------------------------------------

# A[30] = h + A[30] + 1
# x10 ‚Üí base address of A
# x21 ‚Üí h
# x9  ‚Üí temporary for A[30]

#----------------------------------------RISC-V-------------------------------------------

lw   x9, 120(x10)     # Load word from memory: A[30] = Mem[x10 + 120] ‚Üí x9
add  x9, x21, x9      # Add h (x21) and A[30] (x9): x9 = x21 + x9
addi x9, x9, 1        # Add 1 to the result: x9 = x9 + 1
sw   x9, 120(x10)     # Store updated value back to A[30]: Mem[x10 + 120] = x9 

#----------------------------------------Machine-Code-------------------------------------------

# Instruction 1: Load A[30] into x9
lw   x9, 120(x10)         # Load word from address x10 + 120 into x9 (i.e., A[30]) # You access memory by byte address, not element index. If A is an array of 32-bit integers, each element takes 4 bytes. A[30] is at byte offset = 30 √ó 4 = 120
So:
# Machine Code: 000001111000 01010 010 01001 0000011
#               imm[11:0]=000001111000, rs1=01010(x10), funct3=010, rd=01001(x9), opcode=0000011
		|---------|-----|--------|----|--------|
		|immediate| rs1 | funct3 | rd | opcode |
   		|---------|-----|--------|----|--------|			
		| 12 bits |  5  |   3    |  5 | 7 bits |
		|---------|-----|--------|----|--------|	

# Instruction 2: Add h to A[30]
add  x9, x21, x9          # x9 = x21 + x9 (i.e., h + A[30])
# Machine Code: 0000000 01001 10101 000 01001 0110011
#               funct7=0000000, rs2=01001(x9), rs1=10101(x21), funct3=000, rd=01001(x9), opcode=0110011
		|--------|--------|---------|--------|--------|--------|
		| funct7 |  rs2   |   rs1   | funct3 |   rd   | opcode | 
		|--------|--------|---------|--------|--------|--------|
		| 7 bits | 5 bits | 5 bits  | 3 bits | 5 bits | 7 bits |	
		|--------|--------|---------|--------|--------|--------|


# Instruction 3: Add 1 to the result
addi x9, x9, 1            # x9 = x9 + 1
# Machine Code: 000000000001 01001 000 01001 0010011
#               imm=000000000001, rs1=01001(x9), funct3=000, rd=01001(x9), opcode=0010011

		|---------|-----|--------|----|--------|
		|immediate| rs1 | funct3 | rd | opcode |
   		|---------|-----|--------|----|--------|			
		| 12 bits |  5  |   3    |  5 | 7 bits |
		|---------|-----|--------|----|--------|


# Instruction 4: Store result back to A[30]
sw   x9, 120(x10)         # Store word from x9 into address x10 + 120
# Machine Code: 0000011 01001 01010 010 11000 0100011
#               imm[11:5]=0000011, rs2=01001(x9), rs1=01010(x10), funct3=010, imm[4:0]=11000, opcode=0100011

		|---------------|-------|-------|-----|---------|---------|
		|   imm[11:5]   |  rs2  |  rs1	|  f3 | imm[4:0]| sw oppcd|
		|---------------|-------|-------|-----|---------|---------|
		|    	7       |   5   |   5   |  3  |    5    |    7    |
		|---------------|-------|-------|-----|---------|---------|

 # Instruction 4: Store result back to A[30]

|---------|---------|--------|--------|----------|--------|
|imm[11:5]|   rs2   |   rs1  | funct3 | imm[4:0] | opcode |
|---------|---------|--------|--------|----------|--------|
| 0000011 |  01001  | 01010  |   010  |  11000   |0100011 |
|---------|---------|--------|--------|----------|--------|
|   |		|	|	 |	   |	     |
|   |		V	v	 v	   |	     |
    |         source   base    store 	   |	     |
    |	       x14	x2	word	   |	     v
    v					 |       S TYPE
|-----------|----------|	<-------|	 opcode 
| imm[11:5] | imm[4:0] |
|-----------|----------|
|  0000011  | 11000    |	
|-----------|----------|
      |          |
      v          v

	"offset"



#----------------------------------------IMPORTANT-INFORMATION-------------------------------------------


# RISC-V Register Table with 5-bit Binary Codes
# ---------------------------------------------
# Reg  ABI   Binary   |   Reg  ABI   Binary
# ---- ------ ------- |   ---- ------ -------
# x0   zero   00000   |   x16  a6     10000
# x1   ra     00001   |   x17  a7     10001
# x2   sp     00010   |   x18  s2     10010
# x3   gp     00011   |   x19  s3     10011
# x4   tp     00100   |   x20  s4     10100
# x5   t0     00101   |   x21  s5     10101
# x6   t1     00110   |   x22  s6     10110
# x7   t2     00111   |   x23  s7     10111
# x8   s0/fp  01000   |   x24  s8     11000
# x9   s1     01001   |   x25  s9     11001
# x10  a0     01010   |   x26  s10    11010
# x11  a1     01011   |   x27  s11    11011
# x12  a2     01100   |   x28  t3     11100
# x13  a3     01101   |   x29  t4     11101
# x14  a4     01110   |   x30  t5     11110
# x15  a5     01111   |   x31  t6     11111

#----------------------------------------IMPORTANT-INFORMATION-------------------------------------------


#----------------------------------------------U-TYPE---------------------------------------------------

 # ¬∞ RECALL LOAD 32-bit 0X003D0500 into register x19
 # 	¬∞ LUI set the higher 20 bits (adjusted for sign bit from thw lowern 12 bits)
 #	¬∞ ADDI set the lower 12 bits
 #		¬∞ Immediate is sign extended 

# ¬∞ FIELDS in U-TYPE
# 	¬∞ opcode: operation code
#	¬∞ rd    : destination register number 
#	¬∞ imm[31:12]: Those upper 20 bits go into imm[31:12] of the LUI instruction. They are left-shifted by 12 bits, meaning they fill in the upper part of the register, and lower 12 bits are zeros.
		

# ¬∞ OPCODE:
#  LUI: ob_011_0111# ¬∞ RECALL LOAD 32-bit 0X003D0500 into register x19



#--------------------------------EXAMPLE------------------------------------------

lui x1, 0xABCDE    # the 32-bit immediate is 0xABCDE000







